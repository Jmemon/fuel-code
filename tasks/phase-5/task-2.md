# Task 2: Blueprint Schema, Validation, and env.yaml I/O

## Parallel Group: A

## Dependencies: None

## Description

Implement the YAML I/O layer for `.fuel-code/env.yaml` and validation logic for blueprint configurations. This module handles reading, writing, validating, and freezing blueprint files. It uses the existing `BlueprintConfig` type from `packages/shared/src/types/blueprint.ts` and the `js-yaml` package for YAML parsing/serialization.

### Core Functions

```typescript
// packages/core/src/blueprint-io.ts

import type { BlueprintConfig } from '@fuel-code/shared';

// Read .fuel-code/env.yaml from the given directory.
// Returns null if the file does not exist.
// Throws ValidationError if the file exists but is invalid YAML or fails schema validation.
export async function readBlueprint(dir: string): Promise<BlueprintConfig | null>;

// Write a BlueprintConfig to .fuel-code/env.yaml.
// Creates .fuel-code/ directory if needed.
// Includes a header comment explaining the file was auto-generated.
export async function writeBlueprint(dir: string, config: BlueprintConfig): Promise<void>;

// Validate a blueprint config against the Zod schema + semantic checks.
// Returns structured result with human-readable error messages.
export function validateBlueprint(config: BlueprintConfig): ValidationResult;

// Freeze a config into an immutable JSON snapshot for storage in remote_envs.blueprint.
// Includes a SHA-256 hash of the contents for integrity verification.
export function freezeBlueprint(config: BlueprintConfig): FrozenBlueprint;

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

export interface ValidationError {
  field: string;
  message: string;
}

export interface FrozenBlueprint {
  config: BlueprintConfig;
  hash: string;        // SHA-256 hex digest of deterministic JSON
  frozen_at: string;   // ISO-8601 timestamp
}
```

### Validation Rules (beyond Zod schema)

`validateBlueprint` performs semantic checks that go beyond what Zod can express:

- `resources.instance_type` matches a valid AWS pattern: `t3.*`, `t4g.*`, `m5.*`, `m6i.*`, `c5.*`, `c6i.*`, `g4dn.*`, `g5.*`, `r5.*`, `r6i.*`. Rejects obviously wrong values like `t3.nano` (too small for dev envs — minimum `t3.medium`).
- `resources.region` is a valid AWS region string (e.g., `us-east-1`, `eu-west-1`). Validated against a hardcoded allowlist of common regions.
- `docker.base_image` is a non-empty string.
- `resources.disk_gb` is between 20 and 1000.
- `ports` are valid port numbers (1-65535).
- `setup` commands are non-empty strings (no empty strings in the array).
- `runtime` is one of: node, python, go, rust, ruby, generic.

### YAML Header Comment

Written files include:

```yaml
# fuel-code environment blueprint
# Auto-generated by `fuel-code blueprint detect`
# Edit as needed, then run `fuel-code remote up` to provision.
# Docs: https://fuel-code.dev/docs/blueprints

runtime: node
version: "22"
# ...
```

### Relevant Files

**Create:**
- `packages/core/src/blueprint-io.ts`
- `packages/core/src/__tests__/blueprint-io.test.ts`

**Modify:**
- `packages/core/src/index.ts` — export `readBlueprint`, `writeBlueprint`, `validateBlueprint`, `freezeBlueprint`
- `packages/core/package.json` — add `js-yaml` dependency via `bun add js-yaml && bun add -d @types/js-yaml`
- `packages/shared/src/types/blueprint.ts` — verify/extend BlueprintConfig Zod schema if any fields are missing

### Tests

`blueprint-io.test.ts` (bun:test, uses temp directories):

1. `readBlueprint` returns null for nonexistent `.fuel-code/env.yaml`.
2. `readBlueprint` parses valid YAML into a `BlueprintConfig` that passes Zod validation.
3. `readBlueprint` throws `ValidationError` with descriptive message for invalid YAML syntax.
4. `readBlueprint` throws `ValidationError` for YAML that parses but fails schema validation.
5. `writeBlueprint` creates `.fuel-code/` directory if it does not exist.
6. `writeBlueprint` produces valid YAML that round-trips: write then read returns identical config.
7. Written YAML includes header comment with auto-generation notice.
8. `validateBlueprint` catches invalid instance type (e.g., `t3.nano` → error mentioning minimum `t3.medium`).
9. `validateBlueprint` catches invalid region (e.g., `us-east-99`).
10. `validateBlueprint` catches out-of-range disk_gb (e.g., 5 → "must be between 20 and 1000").
11. `validateBlueprint` catches out-of-range ports (e.g., 0, 70000).
12. `validateBlueprint` returns `{ valid: true, errors: [] }` for a valid config.
13. `validateBlueprint` returns multiple errors for a config with multiple issues.
14. `freezeBlueprint` produces deterministic JSON — same input always produces same hash.
15. `freezeBlueprint` hash changes when any field changes.
16. `freezeBlueprint` includes ISO-8601 `frozen_at` timestamp.
17. `js-yaml` is added as a dependency to `packages/core`.

### Success Criteria

1. `readBlueprint` returns null for missing files, valid config for valid YAML, and throws for invalid input.
2. `writeBlueprint` creates directories as needed and produces valid, human-readable YAML with header comments.
3. Round-trip (write → read) preserves all config fields exactly.
4. `validateBlueprint` catches all semantic errors with clear, field-specific messages.
5. `freezeBlueprint` produces deterministic, hashable snapshots.
6. `js-yaml` added to `packages/core` via `bun add`.
